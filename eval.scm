(declare (usual-integrations))

(load "table.scm")
(load "syntax.scm")
(load "apply.scm")

(define eval-table make-table)

(define (expression-type exp)
  (if (pair? exp)
    (car exp)
    exp))

(define (list-of-values exps env)
  (if (no-operands? exps)
    '()
    (cons (eval (first-operand exps) env)
	  (list-of-values (rest-operands exps) env))))

(define (list-of-values-ltr exps env)
  (if (no-operands? exps)
    '()
    (let ((first-val (eval (first-operand exps) env)))
      (cons first-val
	    (list-of-values-ltr (rest-operands exps) env)))))

(define (list-of-values-rtl exps env)
  (if (no-operands? exps env)
    '()
    (let ((right (list-of-values-rtl (rest-operands exps) env)))
      (let ((left (eval (first-operand exps) env)))
	(cons left right)))))

(define (eval-sequence exps env)
  (cond ((last-exp? exps)
	 (eval (first-exp exps) env))
	(else
	  (eval (first-exp exps) env)
	  (eval (rest-exp exps) env))))

(define (install-eval-definitions)
  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))

  (define (eval-and exps env)
    (cond ((null? exps) #t)
	  ((not (true? (eval (car exps) env)))
	   #f)
	  (else
	    (eval-and (cdr exps) env))))

  (define (eval-or exps env)
    (cond ((null? exps) #f)
	  ((true? (eval (car exps) env))
	   #t)
	  (else
	    (eval-or (cdr exps) env))))


  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
			 (eval (assignment-value exp) env)
			 env)
    'ok)

  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
		      (eval (definition-value exp) env)
		      env)
    'ok)

  (define (eval-unbinding exp env)
    (remove-binding! (definition-variable exp)
		     env)
    'ok)

  (define (eval-let exp env)
    (let ((as-combination (let->combination exp)))
      (make-procedure (lambda-parameters (car as-combination))
		      (lambda-body (car as-combination))
		      env)))

  (insert! 'set! eval-assignment eval-table)
  (insert! 'define eval-definition eval-table)
  (insert! 'if eval-if eval-table)
  (insert! 'lambda (lambda (exp env)
		       (make-procedure (lambda-parameters exp)
				       (lambda-body exp)
				       env))
	   eval-table)
  (insert! 'begin (lambda (exp env)
		      (eval-sequence (begin-actions exp) env))
	   eval-table)
  (insert! 'cond 
	   (lambda (exp env)
	     (eval (cond->if exp) env))
	   eval-table)
  (insert! 'and (lambda (exp env)
		(eval-and (and-expressions exp) env))
	  eval-table)
  (insert! 'or (lambda (exp env)
		(eval-or (or-expressions exp) env))
	  eval-table)
  (insert! 'let eval-let eval-table)
  (insert! 'let* (lambda (exp env)
		  (eval (let*->nested-lets exp) env))
	   eval-table)
  (insert! 'make-unbound! eval-unbinding eval-table)
  'done)

(install-eval-definitions)

(define (setup-environment)
  (let ((initial-env
	  (extend-environment (primitive-procedure-names)
			      (primitive-procedure-objects)
			      the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
  initial-env))

(define (eval exp env)
  (let ((fun (lookup (expression-type exp) eval-table)))
    (cond ((self-evaluating? exp) exp)
	  ((variable? exp) (lookup-variable-value exp env))
	  ((quoted? exp) (text-of-quotation exp))
	  (fun (fun exp env))
	  ((application? exp)
	   (apply (eval (operator exp) env)
			(list-of-values (operands exp) env)))
	  (else "Unknown operation type EVAL: exp"))))
