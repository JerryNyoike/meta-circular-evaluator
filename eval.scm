(declare (usual-integrations))

(load "table.scm")
(load "syntax.scm")
(load "apply.scm")

(define eval-table make-table)

(define (expression-type exp)
  (if (pair? exp)
    (car exp)
    exp))

(define (list-of-values exps env)
  (if (no-operands? exps)
    '()
    (cons (eval (first-operand exps) env)
	  (list-of-values (rest-operands exps) env))))

(define (list-of-values-ltr exps env)
  (if (no-operands? exps)
    '()
    (let ((first-val (eval (first-operand exps) env)))
      (cons first-val
	    (list-of-values-ltr (rest-operands exps) env)))))

(define (list-of-values-rtl exps env)
  (if (no-operands? exps env)
    '()
    (let ((right (list-of-values-rtl (rest-operands exps) env)))
      (let ((left (eval (first-operand exps) env)))
	(cons left right)))))

(define (eval-sequence exps env)
  (cond ((last-exp? exps)
	 (eval (first-exp exps) env))
	(else
	  (eval (first-exp exps) env)
	  (eval (rest-exp exps) env))))

(define (install-analyze-definitions)
  (define (analyze-self-evaluating exp)
    (lambda (env) exp))

  (define (analyze-quoted exp)
    (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))

  (define (analyze-variable exp)
    (lambda (env) (lookup-variable-value exp env)))

  (define (analyze-assignment exp)
    (let ((var (assignment-variable exp))
	  (vproc (assignment-value exp)))
      (lambda (env)
	(set-variable-value! var (vproc env) env)
	'ok)))

  (define (analyze-definition exp)
    (let ((var (definition-variable exp))
	  (vproc (definition-value exp)))
      (lambda (env)
	(define-variable! var (vproc env) env)
	'ok)))

  (define (analyze-if exp)
    (let ((pproc (if-predicate exp))
	  (cproc (if-consequent exp))
	  (aproc (if-alternative exp)))
      (lambda (env)
	(if (true? (pproc env))
	  (cproc env)
	  (aproc env)))))

  (define (analyze-lambda exp)
    (let ((params (lambda-parameters exp))
	  (body-proc (lambda-body exp)))
      (lambda (env)
	(make-procedure params body-proc env))))

  (define (analyze-sequence exps)
    (define (sequentially proc1 proc2)
      (lambda (env) (proc1 env) (proc2 env)))
    (define (loop first-proc rest-procs)
      (if (null? rest-procs)
	first-proc
	(loop (sequentially first-proc (car rest-procs))
	      (cdr rest-procs))))
    (let ((procs (map analyze exps)))
      (if (null? procs)
	(error "Empty sequence: ANALYZE")
	(loop (car procs) (cdr procs)))))

  (define (analyze-application exp)
    (let ((fproc (analyze (operator exp)))
	  (aprocs (map (analyze (operands exp)))))
      (lambda (env)
	(execute-application
	  (fproc env)
	  (map (lambda (aproc) (aproc env))
	       aprocs)))))

  (define (execute-application proc args)
    (cond ((primitive-procedure? proc)
	   (apply-primitive-procedure proc args))
	  ((compound-procedure? proc)
	   ((procedure-body proc)
	    (extend-environment
	      (procedure-parameters proc)
	      args
	      (procedure-environment proc))))
	  (else 
	    (error "Unknown procedure type: EXECUTE APPLICATION" proc))))


(define (install-eval-definitions)
  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))

  (define (eval-and exps env)
    (cond ((null? exps) #t)
	  ((not (true? (eval (car exps) env)))
	   #f)
	  (else
	    (eval-and (cdr exps) env))))

  (define (eval-or exps env)
    (cond ((null? exps) #f)
	  ((true? (eval (car exps) env))
	   #t)
	  (else
	    (eval-or (cdr exps) env))))


  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
			 (eval (assignment-value exp) env)
			 env)
    'ok)

  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
		      (eval (definition-value exp) env)
		      env)
    'ok)

  (define (eval-unbinding exp env)
    (remove-binding! (definition-variable exp)
		     env)
    'ok)

  (define (eval-let exp env)
    (let ((as-combination (let->combination exp)))
      (make-procedure (lambda-parameters (car as-combination))
		      (lambda-body (car as-combination))
		      env)))

  (insert! 'set! eval-assignment eval-table)
  (insert! 'define eval-definition eval-table)
  (insert! 'if eval-if eval-table)
  (insert! 'lambda (lambda (exp env)
		       (make-procedure (lambda-parameters exp)
				       (lambda-body exp)
				       env))
	   eval-table)
  (insert! 'begin (lambda (exp env)
		      (eval-sequence (begin-actions exp) env))
	   eval-table)
  (insert! 'cond 
	   (lambda (exp env)
	     (eval (cond->if exp) env))
	   eval-table)
  (insert! 'and (lambda (exp env)
		(eval-and (and-expressions exp) env))
	  eval-table)
  (insert! 'or (lambda (exp env)
		(eval-or (or-expressions exp) env))
	  eval-table)
  (insert! 'let eval-let eval-table)
  (insert! 'let* (lambda (exp env)
		  (eval (let*->nested-lets exp) env))
	   eval-table)
  (insert! 'make-unbound! eval-unbinding eval-table)
  'done)

(install-eval-definitions)

(define (setup-environment)
  (let ((initial-env
	  (extend-environment (primitive-procedure-names)
			      (primitive-procedure-objects)
			      the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
  initial-env))

(define (analyze exp)
  (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
	((variable? exp) (analyze-variable exp))
	((quoted? exp) (analyze-quoted exp))
	((assignment? exp) (analyze-assignment exp))
	((definition? exp) (analyze-definition exp))
	((if? exp) (analyze-if exp))
	((lambda? exp) (analyze-lambda exp))
	((begin? exp) (analyze-begin exp))
	((cond? exp) (analyze-cond exp))
	((application? exp) (analyze-application exp))
	(else (error "Unknown expression type: ANALYZE" exp)))


(define (eval exp env)
  ((analyze exp) env))
  ;(let ((fun (lookup (expression-type exp) eval-table)))
    ;(cond ((self-evaluating? exp) exp)
	  ;((variable? exp) (lookup-variable-value exp env))
	  ;((quoted? exp) (text-of-quotation exp))
	  ;(fun (fun exp env))
	  ;((application? exp)
	   ;(apply (eval (operator exp) env)
			;(list-of-values (operands exp) env)))
	  ;;(else "Unknown operation type EVAL: exp"))))
